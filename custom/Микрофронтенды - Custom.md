# Микрофронтенды - Custom

Микрофронтенды - это относительно независимые веб-приложения, способные выполнятся в веб-контексте и взаимодействовать с сервером/другими веб-приложениями в том же контексте.

Микрофронтенды - вариант реализации сервис-ориентированной архитектуры на клиенте (в браузере).

Основные свойства микросервиса:
- Независимость развёртования и обновления. Возможность отключения микросервиса от системы без существенного ущерба.
- Выполняет только одну достаточно элементарную функцию.
- Зависимости с другими микросервисами одноранговые.
- Реализация сервиса с помощью различных фреймворков

![image](https://github.com/OboyaShka/frontendLectures/assets/66056854/f91bdcbb-ca29-437c-b207-cfd7a86e60f5)

Примеры:
- Виджет погоды
- Комментарии
- Корзина
- Аналитика
- Авторизация

Приемущества:
- Независимость разработки
- Компонентное тестирование
- Экспертиза привязана к компоненту
- Устройчивость системы (слабая связность)
- Автономность развёртования
- Короткий и независимы от других компанд релизный цикл

Недостатки:
- Повышенная сложность системы
- Проблемы со связью компонентов (нужна шина сообщений)

Требования к микрофронтенду:
- Дублирование кода (shared модули/компоненты)
- Инкапсуляция
- Эффективность взаимодействия
- Простота встраивания
- Использование разных фреймворков
- Приемущества развёртования/обновления

 Общие сущности | iframe | shadow dom | css modules | web worker
:------------ | :------------ | :-------------|  :-------------|  :-------------|
DOM | :white_check_mark: | :white_check_mark: | :white_large_square: | :white_large_square:
CSS | :white_large_square: | :white_check_mark: | :white_check_mark: | :white_large_square:
Globals | :white_check_mark: | :white_large_square: | :white_large_square: | :white_check_mark:
Memory | :white_check_mark: | :white_large_square: | :white_large_square: | :white_large_square:
Execution tread | :white_check_mark: | :white_large_square: | :white_large_square: | :white_check_mark:
User events | :white_large_square: | :white_large_square: | :white_large_square: | :white_large_square:
Network | :white_large_square: | :white_large_square: | :white_large_square: | :white_large_square:
Page adress | :white_large_square: | :white_large_square: | :white_large_square: | :white_large_square:
Cookies, cashe, db, local storage | :white_large_square: | :white_large_square: | :white_large_square: | :white_large_square:

Всё, что нельзя инкапсулировать, это веб-контекст, с которым взаимодействуют все микрофронтенды.

Технологии с помощью которых можно реализовать микрофронтенды
- iframe
- Module Federation
- web components (custom elements)

### iframe

Критерий | + | -
:------------ | :------------ | :------------ |
Инкапсуляция | лучшие возможности, собственный window, контроль доступа через атрибуты allow/sandbox | 
Простота встраивания | легко добавляется | ограниченное пространство отрисовки (попапы), расходы по памяти, ограниченное пространство отрисовки
Возможность использования разных языков/фреймворков | Отсутствие ограничений | 
Отсутствие дублирования кода | Один кэш для http | Нет специальных средств
Взаимодействия |  | Нет простого способа взаимодействия с другими микрофронтендами. BroadcastChannel не работает в Safari. Обмен торлько через window.postMessage().
Развёртование | Независимое | 

### Module Federation

План для webpack'а, который позволяет разбить приложение на части и загружать их в runtime по частям

Критерий | + | -
:------------ | :------------ | :------------ |
Инкапсуляция |  | Только в рамках фреймворка
Простота встраивания | | Добавления конфигов и оборачивание приложений в обёртки
Возможность использования разных языков/фреймворков | | Идёт прямое встраивание одного фреймворка в другой, нужна обёртка
Отсутствие дублирования кода | shared модули и библиотеки с одинаковыми версиями | 
Взаимодействия | Из-за отсутствия инкапсуляции взаимодействия проблеми нет | 
Развёртование | Независимое | Риск поломать зависимые приложения (выполнение source кода по сети)

Идеальный вариант для маленького-среднего проекта с одним фреймворком разделить монорепу на модули.

### Web components
План для webpack'а, который позволяет разбить приложение на части и загружать их в runtime по частям

Критерий | + | -
:------------ | :------------ | :------------ |
Инкапсуляция | ShadowDOM + граница распространения ошибки (подключение компонентов по отдельности) | 
Простота встраивания | Легко добавляется на страницу и работает в любом веб-контексте (Custom elements) | FOUC (flash of unstyled content) 
Возможность использования разных языков/фреймворков | Можно использовать любой | Но могут отвалиться библиотки завязанные на document, т.к в shadowRoot это корневой элемент
Отсутствие дублирования кода | Переиспозование засчёт EcmaScipt модулей (нужно доп. библиотека) | 
Взаимодействия | События (Custom Events {bubbles: true, composed:true }) / через определённый интерфейс / с помощью service workers не делать несколько запросов | 
Развёртование | Независимое + автообновления | 

## Web-workers

Веб-воркеры — это потоки, принадлежащие браузеру, которые можно использовать для выполнения JS-кода без блокировки цикла событий. Выделяют 3 вида:
- Выделенные воркеры (Dedicated Workers)
- Разделяемые воркеры (Shared Workers)
- Сервис-воркеры (Service Workers)

1) Экземпляры выделенных веб-воркеров создаются главным процессом. Обмениваться данными с ними может только он.
2) Доступ к разделяемому воркеру может получить любой процесс, имеющий тот же источник, что и воркер (например — разные вкладки браузера, iframe, и другие разделяемый воркеры).
3) Сервис-воркеры — это воркеры, управляемые событиями, зарегистрированные с использованием источника их происхождения и пути. Они могут контролировать веб-страницу, с которой связаны, перехватывая и модифицируя команды навигации и запросы ресурсов, и выполняя кэширование данных, которым можно очень точно управлять. Всё это даёт нам отличные средства управления поведением приложения в определённой ситуации (например, когда сеть недоступна).

Для того чтобы страница, создавшая веб-воркер, могла взаимодействовать с ним, нужно использовать либо метод postMessage, либо широковещательный канал передачи данных, представленный объектом BroadcastChannel (Плохая поддержка).
postMessage принимает только строку или JSON объект, который на самом деле является копией отправленно, так что на сериализацию требуется время. Можно отправить объект, без возможности им пользоваться на отправляющей стороне, но это может быть только ArrayBuffer

Возможности:
- Объект navigator
- Объект location (только для чтения)
- XMLHttpRequest
- setTimeout()/clearTimeout() и setInterval()/clearInterval()
- Кэш приложения
- Импорт внешних скриптов с использованием importScripts()
- Создание других веб-воркеров

Ограничения:
- DOM (это не потокобезопасно)
- Объект window
- Объект document
- Объект parent
