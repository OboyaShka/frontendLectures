# Области тьмы - Custom.md

На собеседованиях часто спрашивают вопросы, касающиеся таких вещей как: замыкание, область видимости, всплытие переменных, "this", контекст выполнения, стек вызовов. Тема мне показалась достаточно обширной и интересной, если начать копать дальше, чем примеры с console.log, поэтому я решил собрать общие знания по теме в этом конспекте. 

И так, сегодня мы узнаем:
- Что такое контекст выполнения и стек вызовов
- Как создаётся контекст выполнения и из чего состоит
- Как реализовано всплытие (Hoisting)
- Что такое this
- Что такое [[Scope]] и ScopeChain
- Как работает замыкание

и закрепим всё на примерах.

## Глава 1 - Погружение в контекст.

Контекст выполнения (execution context) в JavaScript используется для того, чтобы отслеживать ход выполнения кода. Именно с его помощью определяется доступное окружение на текущем этапе выполнения программы. А также контекст выполнения содержит в себе дополнительные параметры, которые формируются самостоятельно JavaScript-движком при обработке кода.

Контекст выполнения тоже является абстрактным механизмом спецификации, как и лексическое окружение, к которому невозможно напрямую обратиться или изменить из программы. По сути он представляет собой некую обертку для выполняемого кода, содержащую определенные вспомогательные компоненты для отслеживания состояния программы, к некоторым из которых, мы можем обратиться из нашего кода.

В JavaScript существует три типа контекстов выполнения:
- Глобальный контекст выполнения (Global Execution Context). Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
- Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
- Контекст выполнения функции eval

Стек выполнения (execution stack / call stack), это LIFO-стек (Last In, First Out), который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.
~~~js
  let a = 'Hello World!';
  function first() {
    console.log('Inside first function');
    second();
    console.log('Again inside first function');
  }
  function second() {
    console.log('Inside second function');
  }
  first();
  console.log('Inside Global Execution Context');
~~~

Для такого кода стэк вызовов будет работать следующим образом.

![e128e212aac1a408b77666b4dcf6a254](https://github.com/OboyaShka/frontendLectures/assets/66056854/de3fa8bb-d26c-464d-a0c8-953a1063f13a)

Каждая функция создаёт новый контекст выполнения со своей лексической областью видимости (об этом далее) и добавляет его в стек. Если внутри функции находится ещё одна, то она по аналогии создаёт ещё один контекст выполения и т.д. После завершения, контекст выполнения убирается из стека и управления переходит предыдущиму контексту.

За этим же call-stack-ом следит event loop.

## Глава 2 - Препарирование контекста

Для начала нужно разобраться с терминами лексическое окружение, область видимости и контекст выполнения, так как это тесно связанные концепции в JavaScript, но они имеют разные значения и выполняют разные функции.

Лексическое окружение - это концептуальная структура, используемая JavaScript для отслеживания объявлений переменных и функций во время выполнения программы. Оно состоит из записи окружения (environment record), которая является коллекцией всех объявленных переменных и функций в данной области видимости, и ссылки на внешнее лексическое окружение, которая позволяет создавать вложенные области видимости.

Область видимости - это область программы, где определенная переменная или функция доступна. В JavaScript области видимости определяются расположением объявлений переменных и функций в исходном коде. Каждая функция имеет свою лексическую область видимости, и любые переменные или функции, объявленные внутри этой функции, доступны только внутри этой функции и любых вложенных функций. Переменные, объявленные за пределами функций, имеют глобальную область видимости и могут быть доступны из любого места в программе.

Контекст выполнения создается каждый раз, когда выполняется JavaScript-код. Он содержит информацию о текуще выполняемом коде, включая значение ключевого слова this, текущую цепочку областей видимости и текущее лексическое окружение. Контексты выполнения могут быть созданы при вызове функции, при выполнении скрипта или при возникновении события.

При создании контекста определяется значение this и осуществляется привязка this (this binding), а также вызывается абстрактная операция NewDeclarativeEnvironment, которая иницилизирует LexicalEnvironment (далее LE) и VariableEnvironment (VE). LE и VE это лексические окружения, которые обладают ссылкой на предыдущую область видимости (outer) и данными о привязке идентификаторов с значениями (EnvironmentRecord).  

Cхематически это выглядит так: 
~~~js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      // Данные о привязках для идентификаторов
    }
    outer: <null>
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      // Данные о привязках для идентификаторов
    }
    outer: <Ссылка на глобальное окружение или на окружение внешней функции>
  }
}
~~~

Область видимости представляет собой определенную область программы, в пределах которой установлена связь между некоторой переменной и её идентификатором. Окружение для области видимости — это доступная из текущей области видимости структура данных, в которой хранятся связи между идентификаторами и переменными из всех внешних областей видимости.
Также важно понимать, что область видимости это место откуда доступная переменная, а окружение это конкретная структура данных. Таким образом переменная может быть доступна в области видимости, но её не будет в текущем окружении (она будет в окружении выще по иерархии). А также в JS используется лексическая области видимости и лексическое окружение (бывает динамическая)

Теперь на примере можно показать, что такое и как работает всплытие переменных. 
Как мы знаем из теории let, const обладают блочной областью видимости, а var и Function Declaration (FD) нет, поэтому они всплывают. Вот как это выглядит на примере:

~~~js
foo(); // Можем вызвать до объявления

console.log(a); // undefined / Но можем обратиться до объявления

var a = 5;

let c = 15;
console.log(c) // 15

{
    //console.log(b); // Ошибка , cannot access 'b' before initialization
    let b = 7;
}
console.log(b); // Ошибка , referenceError: b is not defined

function foo() {
  console.log("foo");
  const d = 16
  let e = 9
  
  console.log(d, e) // 16, 9
}
~~~

Вот как это выглядит на псевдокоде:
~~~js
GlobalExectionContext = {
    LexicalEnvironment: {  // Лексическое окружение блока
        EnvironmentRecord: {
            b: < uninitialized >
        }
        outer:
            LexicalEnvironment: {
                EnvironmentRecord: {
                    c: < uninitialized>
                }
                outer: < VariableEnvironment>
            }
        }
    }
    VariableEnvironment: {
        EnvironmentRecord: {
            a: undefined
            foo: < FooFunctionExectionContext > // ссылка на новый контекст функции
        }
        outer: < null > // null так как это глобальный контекст выполнения
}


FooFunctionExectionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            d: < uninitialized >
            e: < uninitialized >
        }
        outer: < VariableEnvironment>
    }
    VariableEnvironment: {
        EnvironmentRecord: {
        }
        outer: < GlobalExectionContext > // Ссылка на глобальный контекст
}
~~~

JS не исполняется сразу, а происходит JIT-компиляция в 2 шага, парсинг кода в абстрактное синтаксическое дерево/исполняемый байт-код, и
выполнение во время исполнения. Поэтому при создании контекста все переменные всплывают вверх своего лексического окружения (даже let), однако var сразу инициализируется undefined, а FD предопределяется, поэтому их вызов до объявления возможен в отличие от let/const и других примеров, которые попадают в TDZ (Temporal Dead Zone) и вызывают ошибку. 



************************************************************************************************************************************************************************
Источники:
[Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/companies/ruvds/articles/422089/)
[Лексическое окружение (LexicalEnvironment) и Замыкание (Closures) в EcmaScript](https://habr.com/ru/articles/474852/)
[this и ScopeChain в EcmaScript](https://habr.com/ru/articles/468943/)
[Понимаем замыкания в JavaScript. Раз и навсегда](https://medium.com/@stasonmars/понимаем-замыкания-в-javascript-раз-и-навсегда-c211805b6898)
[Что ты такое, замыкания в JavaScript?](https://habr.com/ru/articles/459166/)
[Область видимости. Основы](https://jsflow.org/docs/scope-fundamentals/)
