# Области тьмы - Custom.md

На собеседованиях часто спрашивают вопросы, касающиеся таких вещей как: замыкание, область видимости, всплытие переменных, "this", контекст выполнения, стек вызовов. Тема мне показалась достаточно обширной и интересной, если начать копать дальше, чем примеры с console.log, поэтому я решил собрать общие знания по теме в этом конспекте. 

И так, сегодня мы узнаем:
- Что такое контекст выполнения и стек вызовов
- Как создаётся контекст выполнения и из чего состоит
- Как реализовано всплытие (Hoisting)
- Что такое this
- Что такое [[Scope]] и ScopeChain
- Как работает замыкание

и закрепим всё на примерах.

## Глава 1 - Погружение в контекст.

Контекст выполнения (execution context) в JavaScript используется для того, чтобы отслеживать ход выполнения кода. Именно с его помощью определяется доступное окружение на текущем этапе выполнения программы. А также контекст выполнения содержит в себе дополнительные параметры, которые формируются самостоятельно JavaScript-движком при обработке кода.

Контекст выполнения тоже является абстрактным механизмом спецификации, как и лексическое окружение, к которому невозможно напрямую обратиться или изменить из программы. По сути он представляет собой некую обертку для выполняемого кода, содержащую определенные вспомогательные компоненты для отслеживания состояния программы, к некоторым из которых, мы можем обратиться из нашего кода.

В JavaScript существует три типа контекстов выполнения:
- Глобальный контекст выполнения (Global Execution Context). Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
- Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
- Контекст выполнения функции eval

Стек выполнения (execution stack / call stack), это LIFO-стек (Last In, First Out), который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.
~~~js
  let a = 'Hello World!';
  function first() {
    console.log('Inside first function');
    second();
    console.log('Again inside first function');
  }
  function second() {
    console.log('Inside second function');
  }
  first();
  console.log('Inside Global Execution Context');
~~~

Для такого кода стэк вызовов будет работать следующим образом.

![e128e212aac1a408b77666b4dcf6a254](https://github.com/OboyaShka/frontendLectures/assets/66056854/de3fa8bb-d26c-464d-a0c8-953a1063f13a)

Каждая функция создаёт новый контекст выполнения со своей лексической областью видимости (об этом далее) и добавляет его в стек. Если внутри функции находится ещё одна, то она по аналогии создаёт ещё один контекст выполения и т.д. После завершения, контекст выполнения убирается из стека и управления переходит предыдущиму контексту.

За этим же call-stack-ом следит event loop.

## Глава 2 - Препарирование контекста

При создании контекста определяется значение this и осуществляется привязка this (this binding), а также вызывается абстрактная операция NewDeclarativeEnvironment, которая иницилизирует LexicalEnvironment (далее LE) и VariableEnvironment (VE). LE и VE это окружения области видимости, которые обладают ссылкой на предыдущую область видимости (outer) и данными о привязке идентификаторов с значениями (EnvironmentRecord).  

Cхематически это выглядит так: 
~~~js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      // Данные о привязках для идентификаторов
    }
    outer: <null>
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      // Данные о привязках для идентификаторов
    }
    outer: <Ссылка на глобальное окружение или на окружение внешней функции>
  }
}
~~~

Область видимости представляет собой определенную область программы, в пределах которой установлена связь между некоторой переменной и её идентификатором. Окружение для области видимости — это доступная из текущей области видимости структура данных, в которой хранятся связи между идентификаторами и переменными из всех внешних областей видимости.
Также важно понимать, что область видимости это место откуда доступная переменная, а окружение это конкретная структура данных. Таким образом переменная может быть доступна в области видимости, но её не будет в текущем окружении (она будет в окружении выще по иерархии).



************************************************************************************************************************************************************************
Источники:
[Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/companies/ruvds/articles/422089/)
[Лексическое окружение (LexicalEnvironment) и Замыкание (Closures) в EcmaScript](https://habr.com/ru/articles/474852/)
[this и ScopeChain в EcmaScript](https://habr.com/ru/articles/468943/)
[Понимаем замыкания в JavaScript. Раз и навсегда](https://medium.com/@stasonmars/понимаем-замыкания-в-javascript-раз-и-навсегда-c211805b6898)
[Что ты такое, замыкания в JavaScript?](https://habr.com/ru/articles/459166/)
