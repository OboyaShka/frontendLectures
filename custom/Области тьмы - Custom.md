# Области тьмы - Custom.md

На собеседованиях часто спрашивают вопросы, касающиеся таких вещей как: замыкание, область видимости, всплытие переменных, "this", контекст выполнения, стек вызовов. Тема мне показалась достаточно обширной и интересной, если начать копать дальше, чем примеры с console.log, поэтому я решил собрать общие знания по теме в этом конспекте. 

И так, пора окунуться в области тьмы... сегодня мы узнаем:
- Что такое контекст выполнения и стек вызовов
- Как создаётся контекст выполнения и из чего состоит
- Как реализовано всплытие (Hoisting)
- Что такое this
- Что такое [[SCOPES]] и ScopeChain
- Как работает замыкание

и закрепим всё на примерах.

## Глава 1 - Погружение в контекст.

Контекст выполнения (execution context) в JavaScript используется для того, чтобы отслеживать ход выполнения кода. Именно с его помощью определяется доступное окружение на текущем этапе выполнения программы. А также контекст выполнения содержит в себе дополнительные параметры, которые формируются самостоятельно JavaScript-движком при обработке кода.

Контекст выполнения тоже является абстрактным механизмом спецификации, как и лексическое окружение, к которому невозможно напрямую обратиться или изменить из программы. По сути он представляет собой некую обертку для выполняемого кода, содержащую определенные вспомогательные компоненты для отслеживания состояния программы, к некоторым из которых, мы можем обратиться из нашего кода.

В JavaScript существует три типа контекстов выполнения:
- Глобальный контекст выполнения (Global Execution Context). Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
- Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
- Контекст выполнения функции eval

Стек выполнения (execution stack / call stack), это LIFO-стек (Last In, First Out), который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.
~~~js
  let a = 'Hello World!';
  function first() {
    console.log('Inside first function');
    second();
    console.log('Again inside first function');
  }
  function second() {
    console.log('Inside second function');
  }
  first();
  console.log('Inside Global Execution Context');
~~~

Для такого кода стэк вызовов будет работать следующим образом.

![e128e212aac1a408b77666b4dcf6a254](https://github.com/OboyaShka/frontendLectures/assets/66056854/de3fa8bb-d26c-464d-a0c8-953a1063f13a)

Каждая функция создаёт новый контекст выполнения со своей лексической областью видимости (об этом далее) и добавляет его в стек. Если внутри функции находится ещё одна, то она по аналогии создаёт ещё один контекст выполения и т.д. После завершения, контекст выполнения убирается из стека и управления переходит предыдущиму контексту.

За этим же call-stack-ом следит event loop.

## Глава 2 - Препарирование контекста

Для начала нужно разобраться с терминами лексическое окружение, область видимости и контекст выполнения, так как это тесно связанные концепции в JavaScript, но они имеют разные значения и выполняют разные функции.

Лексическое окружение - это концептуальная структура, используемая JavaScript для отслеживания объявлений переменных и функций во время выполнения программы. Оно состоит из записи окружения (environment record), которая является коллекцией всех объявленных переменных и функций в данной области видимости, и ссылки на внешнее лексическое окружение, которая позволяет создавать вложенные области видимости.

Область видимости - это область программы, где определенная переменная или функция доступна. В JavaScript области видимости определяются расположением объявлений переменных и функций в исходном коде. Каждая функция имеет свою лексическую область видимости, и любые переменные или функции, объявленные внутри этой функции, доступны только внутри этой функции и любых вложенных функций. Переменные, объявленные за пределами функций, имеют глобальную область видимости и могут быть доступны из любого места в программе.

Контекст выполнения создается каждый раз, когда выполняется JavaScript-код. Он содержит информацию о текуще выполняемом коде, включая значение ключевого слова this, текущую цепочку областей видимости и текущее лексическое окружение. Контексты выполнения могут быть созданы при вызове функции, при выполнении скрипта или при возникновении события.

При создании контекста определяется значение this и осуществляется привязка this (this binding), а также вызывается абстрактная операция NewDeclarativeEnvironment, которая иницилизирует LexicalEnvironment (далее LE) и VariableEnvironment (VE). LE и VE это лексические окружения, которые обладают ссылкой на предыдущую область видимости (outer) и данными о привязке идентификаторов с значениями (EnvironmentRecord).  

Cхематически это выглядит так: 
~~~js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      // Данные о привязках для идентификаторов
    }
    outer: <null>
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      // Данные о привязках для идентификаторов
    }
    outer: <Ссылка на глобальное окружение или на окружение внешней функции>
  }
}
~~~

Область видимости представляет собой определенную область программы, в пределах которой установлена связь между некоторой переменной и её идентификатором. Окружение для области видимости — это доступная из текущей области видимости структура данных, в которой хранятся связи между идентификаторами и переменными из всех внешних областей видимости.
Также важно понимать, что область видимости это место откуда доступная переменная, а окружение это конкретная структура данных. Таким образом переменная может быть доступна в области видимости, но её не будет в текущем окружении (она будет в окружении выще по иерархии). А также в JS используется лексическая области видимости и лексическое окружение (бывает динамическая)

Теперь на примере можно показать, что такое и как работает всплытие переменных. 
Как мы знаем из теории let, const обладают блочной областью видимости, а var и Function Declaration (FD) нет, поэтому они всплывают. Вот как это выглядит на примере:

~~~js
foo(); // Можем вызвать до объявления

console.log(a); // undefined / Но можем обратиться до объявления

var a = 5;

let c = 15;
console.log(c) // 15

{
    //console.log(b); // Ошибка , cannot access 'b' before initialization
    let b = 7;
}
console.log(b); // Ошибка , referenceError: b is not defined

function foo() {
  console.log("foo");
  const d = 16
  let e = 9
  
  console.log(d, e) // 16, 9
}
~~~

Вот как это выглядит на псевдокоде:
~~~js
GlobalExectionContext = {
    LexicalEnvironment: {  // Лексическое окружение блока
        EnvironmentRecord: {
            b: < uninitialized >
        }
        outer:
            LexicalEnvironment: {
                EnvironmentRecord: {
                    c: < uninitialized>
                }
                outer: < VariableEnvironment>
            }
        }
    }
    VariableEnvironment: {
        EnvironmentRecord: {
            a: undefined
            foo: < FooFunctionExectionContext > // ссылка на новый контекст функции
        }
        outer: < null > // null так как это глобальный контекст выполнения
}


FooFunctionExectionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            d: < uninitialized >
            e: < uninitialized >
        }
        outer: < VariableEnvironment>
    }
    VariableEnvironment: {
        EnvironmentRecord: {
        }
        outer: < GlobalExectionContext > // Ссылка на глобальный контекст
}
~~~

JS не исполняется сразу, а происходит JIT-компиляция в 2 шага, парсинг кода в абстрактное синтаксическое дерево/исполняемый байт-код, и
выполнение во время исполнения. Поэтому при создании контекста все переменные всплывают вверх своего лексического окружения (даже let), однако var сразу инициализируется undefined, а FD предопределяется, поэтому их вызов до объявления возможен в отличие от let/const и других примеров, которые попадают в TDZ (Temporal Dead Zone) и вызывают ошибку. 

## Глава 3 - THIS IS ЧТО?

Время немного отвлечься и поговорит про this. Опираясь на то, что мы уже поняли про контекст исполнения, можно сказать, что this является свойством контекста, но никак не самим контекстом. Также this присваивается единожды при создании контекста по определённым правилам. Итак, изначально, находясь в глобальном контексте this указывает на глобальный объект или на undefined при strict mode. Если же this вызывается в функции, то нужно быть внимательным:
- в функции конструторе ссылается на создоваемые объект
- в качестве callback'а зависит от реализации, например в обработчиках событий часто ссылается на ноду, в которой произошло событие
- bind, call принудительно привязывают новый контекст
- стрелочная функция не обладает своим this и ссылается на выше стоящий
- вызывается через . у объекта, this равен тому, что слева от точки

Во всех остальных случаях глобальный объект или undefined (если strict mode вкл).

Насчёт последнего пункта нужно быть осторожным, потому что может произойти потеря контекста: 

~~~js
let obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go();               // (1) [object Object]

(obj.go)();             // (2) [object Object]

(method = obj.go)();    // (3) undefined

(obj.go || obj.stop)(); // (4) undefined
~~~

Дело в том, что оператор . возвращает абстрактный тип Reference Type структуры (base, name, strict), который подсказывает контексту к чему привязать this. Поэтому оператор || возвращает конкретную функции без мета-данных из-за чего контекст теряется.

## Глава 4 - SCOOPY DOO

Следующая важная часть для понимания работы контекста это [[SCOPES]] и ScopeChain. 

ScopeChain это цепь областей видимости и она также является свойством контекста исполнения как и this. ScopeChain представляет собой список объектов лексических окружений текущего контекста и всех порождающих контекстов. Именно в этой цепи происходит поиск переменных при разрешении имён идентификаторов.
this связывает функцию с контекстом исполнения, а ScopeChain с порождающими контекстами.

SC = [LO, LO1, LO2,..., LOglobal];

У каждой функции есть свой жизненный цикл, который подразделяется на этап создания и этап выполнения.
В момент создания функции ей присваивается внутреннее свойство [[SCOPES]].
В [[SCOPES]] записывается иерархическая цепь объектов лексических окружений вышестоящих(порождающих) контекстов. Это свойство остаётся неизменным до тех пор пока функция не уничтожена сборщиком мусора.
[[SCOPES]] в отличии от ScopeChain являертся свойством самой функции, а не её контекста.

При вызове функции инициализируется и наполняется её контекст исполнения. Контексту проставляется ScopeChain = LO(самой функции) + [[SCOPES]](иерархическая цепь LO пораждающих контекстов).

Разрешение имён идентификаторов — последовательный опрос объектов LO в цепи ScopeChain слева направо. На выходе получается ReferenceType свойство base которого указывает на объект LO, в котором был найден искомый идентификатор, а PropertyName будет являться строковым представлением имени идентификатора.

Таким образом реализовано замыкание, это результат поиска в ScopeChain всех переменных, идентификаторы которых присутствуют в функции.
Важным исключение является функция-конструктор. Для этого типа функций [[SCOPES]] всегда указывает на глобальный объект.
Также не стоит забывать, что если у какого-то из звеньев в цепи ScopeChain есть прототип, то поиск будет осуществляться и в прототипе тоже.

## Глава 5 - Короткое замыкание

Резюмируя предыдущую главу, при создании функции в [[SCOPES]] записывается цепь лексических окружений вышестоящих контекстов. А при вызове уже самому контексту проставляется ScopeChain, а именно текущее ЛО + [[SCOPES]]. Даже при удалении контекста, где функция была создана, слепок её лексических окружений остаётся в свойстве функции и она имеет доступ к хранящимся там переменным. Это и есть суть замыкании, разберём на примере. Код:
~~~js
const createCounter = () => {
  let currentCounter = 0;

  return () => ++currentCounter;
};

const counter = createCounter();

console.log(counter());
console.log(counter());
console.log(counter());
~~~
Самый простой пример замыкания. Функция createCounter возвращает функцию, которая при вызове увеличивает счётчик и возвращает новое значение. Говоря "научными терминами", при вызове функции createCounter создался новый контекст выполнения, в котором проинициализировалась переменная currentCounter и создалась возвращаемая функция. В [[SCOPES]] возвращаемой функции записалось лексическое окружение функции createCounter, в том числе переменная currentCounter. После завершения функции, контекст выполнения createCounter уничтожился и стек вернулся к глобальному контексту, однако функция присвоенная в переменную counter всё ещё обладает доступом к лексическому окружению, в котором была создана через свойство [[SCOPES]].

![image](https://github.com/OboyaShka/frontendLectures/assets/66056854/9c182601-79bc-4b5b-8556-ed658e215008)

Выглядит это вот так


************************************************************************************************************************************************************************
Источники:
[Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/companies/ruvds/articles/422089/)
[Лексическое окружение (LexicalEnvironment) и Замыкание (Closures) в EcmaScript](https://habr.com/ru/articles/474852/)
[this и ScopeChain в EcmaScript](https://habr.com/ru/articles/468943/)
[Понимаем замыкания в JavaScript. Раз и навсегда](https://medium.com/@stasonmars/понимаем-замыкания-в-javascript-раз-и-навсегда-c211805b6898)
[Что ты такое, замыкания в JavaScript?](https://habr.com/ru/articles/459166/)
[Область видимости. Основы](https://jsflow.org/docs/scope-fundamentals/)
[Ключевое слово this в JavaScript. Полное* руководство])(https://habr.com/ru/articles/464163/)
