# IVY - меньше, быстрее, проще. Антон Никулин

Ivy - движок рендеринга, появившийся в Angular 8, пришедший на смену Renderer2 .

Render Engine - инструмент, который собирает написанные языком фреймворка шаблоны, после чего преобразует их в готовый браузеро-читаемый формат.

Способы компиляции - Just in Time(JIT) и Ahead of Time(AOT)

JIT - компиляция и интерпритация происходит в браузере. Процесс выглядит так:
* Загружается фреймворк с компилятором
* Зарузка кода приложения
* Парсинг кода
* Компиляция в выполняемый код
* Выполнение кода

AOT - компиляция происходит заранее, что исключает компилятор из отправляемого бандла. Процесс выглядит так:
* Загружается фреймворк
* Зарузка кода приложения
* Парсинг кода
* Выполнение кода

Соответственно AOT обладает следующими приемуществами:
* Уменьшенный размер бандла vendor
* Увеличенная производительность
* Повышенная безопасность (Все исходники остаются на сервере)
* Возможность Tree Shaking
* Сразу выявляются ошибки сборки

Приемущество JIT, что все файлы компилируются отдельно и в браузере, следовательно при изменении одного файла в dev режиме, не будет происходить перекомпиляции всего приложения

В Renderer2 была проблема, что сборка в AOT компиляции была слишком долгой, из-за того, что при каждом изменении файла, происходила полная перекомпиляция всего приложения. Выглядел процесс рендеринга так:

Шаблон HTML => Описание шаблона => Angular интерпритатор => DOM

Также в AOT компиляции Renderer2 формировались .metadata.json файлы, описывающие структуру компонентов и их зависимости, а также js фабрики компонентов. Это усложняло подключение AOT собранных библиотек, потому что нужно было пересобирать всё приложение.

Приход IVY был призван решить следующие проблемы:
* Долгое время сборки + пересборка всего приложения при изменении в одном компоненте
* Размер бандла
* Код фреймворка находится в одном файле
* Сложно использовать сторонний AOT

Ivy позволяет компонентам быть самодостаточными и компилироваться отдельно, используя только внутренние зависимости. Также привносится Code Spliting бандла на чанки. Процесс рендеринга сейчас происходит так:

Шаблон HTML => Инструкции для шаблона => DOM

Такое возможно благодаря использованию [Incremental Dom](https://habr.com/ru/articles/448048/)

~~~typescript
@Component({
  selector: 'todos-cmp',
  template: `
    <div *ngFor="let t of todos|async">
        {{t.description}}
    </div>
  `
})
class TodosComponent {
  todos: Observable<Todo[]> = this.store.pipe(select('todos'));
  constructor(private store: Store<AppState>) {}
}
~~~

Компилируется в 

~~~typescript
var TodosComponent = /** @class */ (function () {
  function TodosComponent(store) {
    this.store = store;
    this.todos = this.store.pipe(select('todos'));
  }

  TodosComponent.ngComponentDef = defineComponent({
    type: TodosComponent,
    selectors: [["todos-cmp"]],
    factory: function TodosComponent_Factory(t) {
      return new (t || TodosComponent)(directiveInject(Store));
    },
    consts: 2,
    vars: 3,
    template: function TodosComponent_Template(rf, ctx) {
      if (rf & 1) { // create dom
        pipe(1, "async");
        template(0, TodosComponent_div_Template_0, 2, 1, null, _c0);
      } if (rf & 2) { // update dom
        elementProperty(0, "ngForOf", bind(pipeBind1(1, 1, ctx.todos)));
      }
    },
    encapsulation: 2
  });

  return TodosComponent;
}());
~~~

При этом функция template содержит инструкции для рендеринга и обновления DOM. Инструкции не интерпретируются движком рендеринга фреймворка. Они и есть движок рендеринга.

Плюсы Incremental Dom
* При использовании incremental DOM фреймворк не интерпретирует компонент; вместо этого компонент ссылается на инструкции. Если какая-либо инструкция осталась нетронутой, то она не будет использоваться в будущем. Поскольку данная информация известна во время компиляции, можно исключить неиспользуемые инструкции из бандла.
* Incremental DOM не требует памяти для повторного рендеринга представления, если оно не вносит изменения в DOM. Память необходимо будет выделить только в том случае, если будут добавлены или удалены DOM-узлы, а объём выделяемой памяти будет пропорционален производимым изменениям в DOM.
* Incremental DOM хорошо подходит для концепции работы с html шаблонами


[Лекция](https://www.youtube.com/watch?v=gZ7QEWh9ECE) 
